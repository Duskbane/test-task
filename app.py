from flask import Flask, request, render_template
import psycopg2 
import json

app = Flask(__name__)

# =============================================================================
# DATABASE-RELATED
# =============================================================================

# for convenience
# can be used with different users (settings.dat file)
global databaseInfo
databaseInfo = []

def createNewDatabase(cursor):
    # return true if db_todo already exists
    cursor.execute("select exists(SELECT datname FROM pg_catalog.pg_database WHERE lower(datname) = lower('db_todo'));")

    # if doesn't exist
    if not cursor.fetchone()[0]:
        cursor.execute("CREATE database db_todo")
        
def createTasksTable(cursor):
    cursor.execute("CREATE TABLE IF NOT EXISTS public.tasks( \
       id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ), \
       text text, \
       date TIMESTAMPTZ, \
       state boolean, \
       CONSTRAINT tasks_pkey PRIMARY KEY (id))")
        
def connectToDatabase(data):     
    conn = psycopg2.connect(
        database = data[0], user = data[1], password = data[2], host = data[3], port = data[4]) 
    
    # all changes apply to db 
    conn.autocommit = True
    return conn

def initDatabase():
    global databaseInfo
    
    # to create db_todo
    f = open("settings.dat", "r")
    databaseData = f.readline().split(';')
    
    conn = connectToDatabase(databaseData) 
    cursor = conn.cursor()
    createNewDatabase(cursor)
    conn.close()
    
    # to create table
    # readline returns 2nd line as the file hasn't been closed yet
    databaseData = f.readline().split(';')
    databaseInfo = ['db_todo'] + databaseData
    
    conn = connectToDatabase(databaseInfo)
    cursor = conn.cursor()
    createTasksTable(cursor)
    
    conn.close()
    f.close()
    
# =============================================================================
# APP-RELATED
# =============================================================================

class Task:
    def __init__(self, id_t, info, date, state):
        self.id = id_t
        self.info = info
        self.date = date
        self.state = state
        
    # for debugging purposes
    def __str__(self):
        return "task " + self.id + ", state - " + str(self.state) + ", creation date - " + str(self.date)

def getTaskDataFromRequest(req):
    # req - json file from website containing task info
    taskID = req["id_t"]
    taskText = req["text"]
    taskDate = req["date"]
    taskState = req["state"]
    return Task(taskID, taskText, taskDate, taskState)

# declared global as it changes in multiple functions in different ways
taskList = []

@app.route('/', methods=['GET'])
def gets():
    # probably wrong return, but an error is given with empty one
    # same applies to functions below
    return render_template("ToDo.html") 

@app.route('/add', methods=['POST'])
def getTask():
    requestData = request.get_json()
    
    newTask = getTaskDataFromRequest(requestData)
    taskList.append(newTask)
    return render_template("ToDo.html")

@app.route('/change', methods=['POST'])
def changeState():
    requestData = request.get_json()
    
    modifiedTask = getTaskDataFromRequest(requestData)
    for i in range(len(taskList)):
        if taskList[i].id == modifiedTask.id:
            taskList[i] = modifiedTask
            break
    return render_template("ToDo.html")

@app.route('/delete', methods=['POST'])
def deleteTask():
    requestData = request.get_json()
    
    # this time request only returns id
    taskIDToDelete = requestData
    for i in range(len(taskList)):
        # conversion id to string only needed here, because
        # in the functions above ids are being compared to ids
        # and taskIDToDelete is an int
        if str(taskList[i].id) == taskIDToDelete:
            del taskList[i]
            break
    return render_template("ToDo.html")

@app.route('/save', methods=['POST'])
def saveTasks():
    requestData = request.get_json()
    
    # example data - [{'id_t': '5', 'text': 'fwerqr', 'date': '2024-03-06T14:53:00.328Z', 'state': False}]
    conn = connectToDatabase(databaseInfo)
    cursor = conn.cursor()

    for i in requestData:
        cursor.execute("INSERT INTO tasks (text, date, state) \
                        VALUES ('%s', '%s', %s);" %(i['text'], i['date'], i['state']))
    conn.close()
    return render_template("ToDo.html")

@app.route('/load', methods=['GET'])
def loadTasks():
    
    conn = connectToDatabase(databaseInfo)
    cursor = conn.cursor()
    
    cursor.execute("SELECT * FROM tasks")
    tasks = cursor.fetchall()
    
    cursor.execute("DELETE FROM tasks")
    conn.close()
    
    # tasks - tuple, so date can't be just swapped like tasks[2] = newDate
    taskList = []
    for i in range(len(tasks)):
        task = list()
        
        # copy task data to list properly changing date to string
        # because chosen date format can't be processed by json.dumps
        for j in range(len(tasks[i])):
            if j == 2:
                task.append(datetimeToDateObjectFormat(tasks[i][j]))
            else:
                task.append(tasks[i][j])
        taskList.append(task)
    
    return json.dumps(taskList)

def datetimeToDateObjectFormat(date):
    
    if not date == None: # in case date is not set somehow
        newdate = str(date)
        # default js acceptable string for Date object in a full form 
        # YYYY-MM-DDTHH:mm:ss.sssZ
        return newdate[:10] + 'T' + newdate[11:23] + newdate[26:]
    return None
# =============================================================================
# START
# =============================================================================

if(__name__ == "__main__"):
    
    initDatabase()
    app.run()